;startup address
* = $0801

;create BASIC startup (SYS line)
!basic

;debuglines   = 1
;userasterirq = 1

screen1 = $0400
;screen1 = $2000 

        ; set start of screen memory
        ; see https://www.c64-wiki.de/wiki/Bildschirmspeicher
        lda $d018
        and #%00001111
        ora #(screen1 / 1024) << 4
        sta $d018

        ; init sid max freq        
        lda #$ff
        sta $d40e
        sta $d40f
        lda #$80
        sta $d412         ; noise waveform        

        lda #$be
        jsr clearcolorram
        
!ifdef userasterirq {
        jsr init_irq
        jmp *             ; endless loop       
} else {
        jmp busywait
}
        
!ifndef userasterirq {      
busywait:
        sei 
        
--      lda #$fc          ; wait for raster line $fc. 
-       cmp $d012         
        bne -    

        jsr scroll       
        
        lda $dc01         ; spacebar pressed?
        cmp #$ff
        beq --
        
        lda $d011         ; restore scroll offset
        and #%11111000
        ora #%00000011
        sta $d011        

!if screen1 != $0400 {
        lda $d018         ; restore original screen mem if other was used
        and #%00001111
        ora #($0400 / 1024) << 4
        sta $d018
}       
        cli 
        
        rts
}

; --------------------------------------------------------------------------------------
; Init raster interrupt
; --------------------------------------------------------------------------------------

!ifdef userasterirq {
init_irq:
        sei               ; set interrupt bit, make the CPU ignore interrupt requests

        lda #$40          ; wait for raster line $40. 
-       cmp $d012         ; don't know why I need this. Otherwise rastr_irq is only called once if 
        bne -             ; the current raster line < $35 or > $fe

        lda #%01111111    
        sta $dc0d         ; disable timer interrupts which can be generated by the two CIA chips
        sta $dd0d         ; the kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better
                          ; stop it.

        lda $dc0d         ; by reading this two registers we negate any pending CIA irqs.
        lda $dd0d         ; if we don't do this, a pending CIA irq might occur after we finish setting up our irq.
                          ; we don't want that to happen.

        lda #%00000001    ; raster line triggers interrupt
        sta $d01a
        
        lda #$fc          ; set rasterline where interrupt shall occur
        sta $d012
        
        lda $d011         ; clear high bit
        and #%01111111
        sta $d011

        lda #$35          ; we turn off the BASIC and KERNAL rom here
        sta $01           ; the cpu now sees RAM everywhere except at $d000-$e000, where still the registers of
                          ; SID/VICII/etc are visible

        lda #<rastr_irq   ; this is how we set up
        sta $fffe         ; the address of our interrupt code
        lda #>rastr_irq
        sta $ffff
        
        cli               ; clear interrupt flag, allowing the CPU to respond to interrupt requests
        
        rts
}
         
; --------------------------------------------------------------------------------------
; Raster interrupt
; --------------------------------------------------------------------------------------

!ifdef userasterirq {
rastr_irq:
        pha               ; store register A in stack
        txa
        pha               ; store register X in stack
        tya
        pha               ; store register Y in stack

        asl $d019         ; IRQ bestätigen

        jsr scroll       
        
        pla
        tay               ; restore register Y from stack (remember stack is FIFO: First In First Out)
        pla
        tax               ; restore register X from stack
        pla               ; restore register A from stack

        rti               ; Return From Interrupt, this will load into the Program Counter register the address
                          ; where the CPU was when the interrupt condition arised which will make the CPU continue
                          ; the code it was interrupted at also restores the status register of the CPU        
}
        
; --------------------------------------------------------------------------------------
; Smooth scrolling
; --------------------------------------------------------------------------------------

scroll: 
!ifdef debuglines {
        lda #$7
        sta $d020         ; change border colour to yellow
}
        lda $d011
        and #%111
        tax
        dex
        bmi +
        dec $d011
        jmp ++
        
+       lda $d011
        ora #%111
        sta $d011
        jsr shiftup
        jsr newline

++
!ifdef debuglines {
        lda #$0
        sta $d020         ; change border colour to black
}        
        rts

newline:
        ; fill last line with random chars
        ldx #39
-       lda $d41b
        ror 
        lda #77
        adc #0
        sta screen1+40*24,x
        dex
        bpl -
        rts

shiftup:
        ; Shift the screen memory one row up.
        ; We do this in blocks of 10*25 bytes.
        clc
        lda #0
-       tax
        lda screen1+40+000,x
        sta screen1+00+000,x
        lda screen1+41+000,x
        sta screen1+01+000,x
        lda screen1+42+000,x
        sta screen1+02+000,x
        lda screen1+43+000,x
        sta screen1+03+000,x
        lda screen1+44+000,x
        sta screen1+04+000,x
        lda screen1+45+000,x
        sta screen1+05+000,x
        lda screen1+46+000,x
        sta screen1+06+000,x
        lda screen1+47+000,x
        sta screen1+07+000,x
        lda screen1+48+000,x
        sta screen1+08+000,x
        lda screen1+49+000,x
        sta screen1+09+000,x
        txa 
        adc #10
        cmp #250
        bne -
        
        clc
        lda #0
-       tax
        lda screen1+40+250,x
        sta screen1+00+250,x
        lda screen1+41+250,x
        sta screen1+01+250,x
        lda screen1+42+250,x
        sta screen1+02+250,x
        lda screen1+43+250,x
        sta screen1+03+250,x
        lda screen1+44+250,x
        sta screen1+04+250,x
        lda screen1+45+250,x
        sta screen1+05+250,x
        lda screen1+46+250,x
        sta screen1+06+250,x
        lda screen1+47+250,x
        sta screen1+07+250,x
        lda screen1+48+250,x
        sta screen1+08+250,x
        lda screen1+49+250,x
        sta screen1+09+250,x
        txa 
        adc #10
        cmp #250
        bne -

        clc
        lda #0
-       tax
        lda screen1+40+500,x
        sta screen1+00+500,x
        lda screen1+41+500,x
        sta screen1+01+500,x
        lda screen1+42+500,x
        sta screen1+02+500,x
        lda screen1+43+500,x
        sta screen1+03+500,x
        lda screen1+44+500,x
        sta screen1+04+500,x
        lda screen1+45+500,x
        sta screen1+05+500,x
        lda screen1+46+500,x
        sta screen1+06+500,x
        lda screen1+47+500,x
        sta screen1+07+500,x
        lda screen1+48+500,x
        sta screen1+08+500,x
        lda screen1+49+500,x
        sta screen1+09+500,x
        txa 
        adc #10
        cmp #250
        bne -
        
        clc
        lda #0
-       tax
        lda screen1+40+750,x
        sta screen1+00+750,x
        lda screen1+41+750,x
        sta screen1+01+750,x
        lda screen1+42+750,x
        sta screen1+02+750,x
        lda screen1+43+750,x
        sta screen1+03+750,x
        lda screen1+44+750,x
        sta screen1+04+750,x
        lda screen1+45+750,x
        sta screen1+05+750,x
        lda screen1+46+750,x
        sta screen1+06+750,x
        lda screen1+47+750,x
        sta screen1+07+750,x
        lda screen1+48+750,x
        sta screen1+08+750,x
        lda screen1+49+750,x
        sta screen1+09+750,x
        txa 
        adc #10
        cmp #210      
        bne -
        rts

; --------------------------------------------------------------------------------------
; Misc routines
; --------------------------------------------------------------------------------------

clearcolorram:
        ldx   #250
-       dex         ; this sets Z flags if last round
        sta   $d800+000,x
        sta   $d800+250,x
        sta   $d800+500,x
        sta   $d800+750,x
        bne   -
        rts

!if 0 {
fillscreen:
        lda #$be
        jsr clearcolorram
        lda #0
        sta .f
        lda #<screen1
        sta .faddr+1
        lda #>screen1
        sta .faddr+2
        ldy #25-1
.lp     inc .f
        lda .f
        ldx #40-1
.faddr  sta screen1,x
        dex
        bpl .faddr
        lda .faddr+1
        clc
        adc #40
        sta .faddr+1
        bcc +
        inc .faddr+2   
+       dey 
        bpl .lp
        rts
        
.f      !byte 0
}
